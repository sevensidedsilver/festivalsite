<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Massive.js by dmfay</title>

    <link rel="stylesheet" href="/massive-js/assets/css/style.css?v=8f3b5004dbc09941550749da6d7e90b279e958cc">
    <link rel="stylesheet" href="/assets/css/custom.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="/massive-js">Massive.js</a></h1>
        <p>Massive.js is a data mapper for Node.js that goes all in on PostgreSQL and fully embraces the power and flexibility of the SQL language and relational metaphors. Providing minimal abstractions for the interfaces and tools you already use, its goal is to do just enough to make working with your data as easy and intuitive as possible, then get out of your way.
</p>

        
          <p class="view"><a href="http://github.com/dmfay/massive-js">View the Project on GitHub <small></small></a></p>
        

        <h2>Contents</h2>
        <ul class="toc">
          <li><a href="/massive-js/connecting.html">Connecting</a></li>
          <li><a href="/massive-js/criteria.html">Criteria Objects</a></li>
          <li><a href="/massive-js/queries.html">Queries</a></li>
          <li><a href="/massive-js/persistence.html">Persistence</a></li>
          <li><a href="/massive-js/documents.html">Working with Documents</a></li>
          <li><a href="/massive-js/functions.html">Functions and Scripts</a></li>
          <li><a href="/massive-js/run.html">Raw SQL</a></li>
          <li><a href="/massive-js/api/index.html">API Docs</a></li>
        </ul>

        

        
        <p>This project is maintained by <a href="http://github.com/dmfay">dmfay</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>

        
      </header>
      <section>

      <h1 id="functions">Functions</h1>

<p>Object-relational mappers tend to ignore functions. For many, the database exists solely as a repository, with data manipulation reserved for application logic and external jobs.</p>

<p>To be fair, this setup is perfectly sufficient for many use cases. But when it isn’t, it <em>hurts</em>. With functions, you can perform complex operations on your data at a scope and speed unrivaled by anything else. Why go to the trouble of querying bulk data into another system and manipulating it – only to put it back where it was with a second trip across the wire? Especially when there’s a powerful, flexible language purpose-built for set operations <em>right there</em>? You wouldn’t work that way, and Massive won’t make you: functions are first-class citizens as far as it’s concerned.</p>

<h2 id="database-functions">Database Functions</h2>

<p>All functions visible to the connecting role are attached to the Massive instance, unless the loader configuration restricts function loading. See the <a href="connecting">Connecting</a> chapter for more information.</p>

<h2 id="the-scripts-directory">The Scripts Directory</h2>

<p>Massive doesn’t stop at the functions present in the database itself: on startup, it looks for script files in your project and loads them up too. These files are prepared statements and can use <code class="highlighter-rouge">$1</code>-style placeholders.</p>

<p>By default, Massive searches the <code class="highlighter-rouge">/db</code> directory, but this can be customized by setting the <code class="highlighter-rouge">scripts</code> property in the loader configuration. The scripts directory can contain further subdirectories; like schemas, these are treated as namespaces. Unlike schemas, they can be nested to arbitrary depth.</p>

<p>Like <code class="highlighter-rouge">run</code>, prepared statements in script files can use named parameters instead of <code class="highlighter-rouge">$1</code>-style indexed parameters. Named parameters are formatted <code class="highlighter-rouge">${name}</code>. Other delimiters besides braces are supported; consult the pg-promise documentation for a full accounting.</p>

<p>Prepared statement scripts must consist of one and only one SQL statement. Common table expressions or CTEs can take some of the sting out of this requirement, but if you need to execute multiple statements with arbitrary parameters it’s time to turn it into a proper function.</p>

<h2 id="invocation">Invocation</h2>

<p>Massive treats functions and scripts identically. Each is attached as a function which may be invoked directly. Parameters may be passed in one by one or as an array. Results are returned in the usual Massive style as an array of objects.</p>

<p>If <code class="highlighter-rouge">enhancedFunctions</code> is set to <code class="highlighter-rouge">true</code> in the loader configuration, functions returning scalars or flat arrays will be intercepted and the results massaged into scalars or flat arrays, as appropriate. Since this represents a departure from the consistent form, it must be explicitly enabled on initialization.</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">uuid_generate_v1mc</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">arr</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// an array containing the generated UUID (requires the</span>
  <span class="c1">// uuid-ossp extension)</span>
<span class="p">});</span>

<span class="nx">db</span><span class="p">.</span><span class="nx">myTestQueries</span><span class="p">.</span><span class="nx">restartTests</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">results</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// this runs the prepared statement in</span>
  <span class="c1">// db/myTestQueries/restartTests.sql with the above</span>
  <span class="c1">// parameters and returns any output from a RETURNING clause</span>
<span class="p">});</span>

<span class="nx">db</span><span class="p">.</span><span class="nx">myTestQueries</span><span class="p">.</span><span class="nx">restartTests</span><span class="p">({</span>
  <span class="na">category</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="na">force</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">results</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// as above; the prepared statement should use ${category}</span>
  <span class="c1">// and ${force} instead of $1 and $2.</span>
<span class="p">});</span>
</code></pre>
</div>


      </section>
    </div>
    <script src="/massive-js/assets/js/scale.fix.js"></script>


  
  </body>
</html>

